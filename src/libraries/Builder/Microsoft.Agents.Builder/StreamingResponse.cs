// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using Microsoft.Agents.Builder.Errors;
using Microsoft.Agents.Core;
using Microsoft.Agents.Core.Errors;
using Microsoft.Agents.Core.Models;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.Agents.Builder
{
    /// <summary>
    /// This class enables sending chunked text in a series of "intermediate" messages, on an interval.  This
    /// gives the UX of a streamed message. When complete, a final message (ActivityType.Message) is sent with 
    /// the full message and optional Attachments.
    /// 
    /// The expected sequence of calls is:
    /// 
    /// `QueueInformativeUpdateAsync()`, `QueueTextChunk()`, `QueueTextChunk()`, ..., `EndStreamAsync()`.
    ///
    ///  Once `EndStreamAsync()` is called, the stream is considered ended and no further updates can be sent.
    /// </summary>
    /// <remarks>
    /// Only Teams and WebChat support streaming messages.  However, channels that do not support
    /// streaming messages will only receive the final message when <see cref="EndStreamAsync"/> is called.
    /// </remarks>
    /// <remarks>
    /// This class support throttling via the <see cref="Interval"/> property.  Teams and Azure Channels require
    /// some throttling since services like OpenAI produce streams that exceed allowed Channel message limits.
    /// Teams defaults to 1000ms per intermediate message, and WebChat 500ms.  Reducing the Interval could result
    /// in message delivery failures.
    /// </remarks>
    internal class StreamingResponse : IStreamingResponse
    {
        public static readonly int DefaultEndStreamTimeout = (int)TimeSpan.FromMinutes(2).TotalMilliseconds;

        private const string TeamsStreamCancelled = "ContentStreamNotAllowed";
        // Teams failed to accept streaming messages. 
        private const string BadArgument = "BadArgument";
        private const string TeamsStreamNotAllowed = "streaming api is not enabled";

        private readonly TurnContext _context;
        private readonly ISubject<IActivity> _activitySubject = Subject.Synchronize(new Subject<IActivity>());
        private DynamicIntervalTextChunkBatcher _textBatcher;
        private IDisposable _batcherSubscription;
        private IDisposable _activitySubscription;
        private int _nextSequence = 1;
        private bool _ended = false;
        private bool _isTeamsChannel;
        private bool _canceled;
        private bool _userCanceled;
        private bool _streamStarted = false;
        private string _accumulatedMessage = "";
        private TaskCompletionSource<bool> _streamCompleteTcs = new TaskCompletionSource<bool>();
        private int _interval;

        /// <summary>
        /// Set IActivity that will be (optionally) used for the final streaming message.
        /// </summary>
        public IActivity FinalMessage { get; set; }

        /// <summary>
        /// Gets the stream ID of the current response.
        /// Assigned after the initial update is sent.
        /// </summary>
        private string StreamId { get; set; }

        /// <summary>
        /// The buffered message.
        /// </summary>
        public string Message { get; private set; } = "";

        /// <summary>
        /// Sets the "Generated by AI" label in Teams.
        /// Defaults to false.
        /// </summary>
        public bool? EnableGeneratedByAILabel { get; set; } = false;

        /// <summary>
        /// The citations for the response.
        /// </summary>
        public List<ClientCitation>? Citations { get; set; } = [];

        /// <summary>
        /// The sensitivity label for the response.
        /// </summary>
        public SensitivityUsageInfo? SensitivityLabel { get; set; }

        /// <summary>
        /// The interval in milliseconds at which intermediate messages are sent.
        /// </summary>
        /// <remarks>
        /// Teams default: 1000
        /// WebChat default: 500
        /// </remarks>
        public int Interval
        {
            get => Volatile.Read(ref _interval);
            set
            {
                Volatile.Write(ref _interval, value);
                _textBatcher?.SetInterval(value);
            }
        }

        public int EndStreamTimeout { get; set; } = DefaultEndStreamTimeout;

        /// <summary>
        /// Indicate if the current channel supports intermediate messages.
        /// </summary>
        /// <remarks>
        /// Channels that don't support intermediate messages will buffer
        /// text, and send a normal final message when EndStreamAsync is called.
        /// </remarks>
        public bool IsStreamingChannel { get; private set; }

        /// <summary>
        /// Gets the number of updates sent for the stream.
        /// </summary>
        /// <returns>Number of updates sent so far.</returns>
        public int UpdatesSent() => _nextSequence - 1;

        /// <summary>
        /// Creates a new instance of the <see cref="StreamingResponse"/> class.
        /// </summary>
        /// <param name="turnContext">Context for the current turn of conversation with the user.</param>
        public StreamingResponse(TurnContext turnContext)
        {
            AssertionHelpers.ThrowIfNull(turnContext, nameof(turnContext));

            _context = turnContext;
            SetDefaults(turnContext);

            if (IsStreamingChannel)
            {
                SetupStreamingPipeline();
            }
        }

        private void SetupStreamingPipeline()
        {
            _textBatcher = new DynamicIntervalTextChunkBatcher(Interval);

            // Subscribe to batched text emissions
            _batcherSubscription = _textBatcher.Subscribe(text =>
            {
                Message = text;
                var activity = CreateStreamingActivity("Streaming", text);
                _activitySubject.OnNext(activity);
            });

            // Subscribe to activity emissions to send them
            _activitySubscription = _activitySubject
                .Subscribe(
                    async activity =>
                    {
                        await SendActivityAsync(activity, CancellationToken.None).ConfigureAwait(false);
                    },
                    error =>
                    {
                        _canceled = true;
                        _streamCompleteTcs.TrySetResult(true);
                    },
                    () =>
                    {
                        _streamCompleteTcs.TrySetResult(true);
                    });
        }


        private Activity CreateStreamingActivity(string streamType, string text)
        {
            var activity = new Activity
            {
                Type = ActivityTypes.Typing,
                Text = text,
                Entities = []
            };

            var streamInfo = new StreamInfo
            {
                StreamSequence = Interlocked.Increment(ref _nextSequence) - 1
            };

            if (streamType == "Informative")
            {
                streamInfo.StreamType = StreamTypes.Informative;
            }
            else
            {
                streamInfo.StreamType = StreamTypes.Streaming;

                if (Citations != null && Citations.Count > 0)
                {
                    List<ClientCitation>? currCitations = CitationUtils.GetUsedCitations(text, Citations);
                    AIEntity entity = new();
                    if (currCitations != null && currCitations.Count > 0)
                    {
                        entity.Citation = currCitations;
                    }
                    activity.Entities.Add(entity);
                }
            }

            activity.Entities.Add(streamInfo);
            return activity;
        }

        /// <summary>
        /// Adds a citation to the collection at the specified position.
        /// </summary>
        /// <remarks>The citation's appearance is automatically generated based on its title, content, and URL.</remarks>
        /// <param name="citation">The citation to add. Must not be <see langword="null"/>.</param>
        /// <param name="citationPosition">The position of the citation in the collection. Must be a non-negative integer.</param>
        public void AddCitation(Citation citation, int citationPosition)
        {
            Citations ??= [];
            Citations.Add(new ClientCitation()
            {
                Position = citationPosition,
                Appearance = new ClientCitationAppearance()
                {
                    Name = citation.Title ?? $"Document #{citationPosition}",
                    Abstract = CitationUtils.Snippet(citation.Content, 480),
                    Url = citation.Url
                }
            });
        }

        /// <summary>
        ///  Sets the citations for the full message.
        /// </summary>
        /// <remarks>The citation's appearance is automatically generated based on its title, content, and URL. Citations are numbed in the order they appear on the list.</remarks>
        /// <param name="citations">Citations to be included in the message.</param>
        public void AddCitations(IList<Citation> citations)
        {
            if (citations.Count > 0)
            {
                Citations ??= [];

                int currPos = Citations.Count;

                foreach (Citation citation in citations)
                {
                    Citations.Add(new ClientCitation()
                    {
                        Position = currPos + 1,
                        Appearance = new ClientCitationAppearance()
                        {
                            Name = citation.Title ?? $"Document #{currPos + 1}",
                            Abstract = CitationUtils.Snippet(citation.Content, 480),
                            Url = citation.Url
                        }
                    });
                    currPos++;
                }
            }
        }

        /// <summary>
        /// Adds a ClientCitation to the Citations list.
        /// </summary>
        /// <param name="citation">ClientCitation to add to the stream</param>
        public void AddCitation(ClientCitation citation)
        {
            Citations ??= [];
            Citations.Add(citation);
        }

        /// <summary>
        /// Adds multiple ClientCitations to the Citations list.
        /// </summary>
        /// <param name="citations">The ClientCitations to add.</param>
        public void AddCitations(IList<ClientCitation> citations)
        {
            if (citations.Count > 0)
            {
                Citations ??= [];
                Citations.AddRange(citations);
            }
        }

        /// <summary>
        /// Queues an informative update to be sent to the client.
        /// </summary>
        /// <param name="text">Text of the update to send.</param>
        /// <param name="cancellationToken"></param>
        /// <exception cref="System.InvalidOperationException">Throws if the stream has already ended.</exception>
        public async Task QueueInformativeUpdateAsync(string text, CancellationToken cancellationToken = default)
        {
            if (!IsStreamingChannel)
            {
                return;
            }

            if (_ended)
            {
                throw Core.Errors.ExceptionHelper.GenerateException<InvalidOperationException>(ErrorHelper.StreamingResponseEnded, null);
            }

            _streamStarted = true;
            var activity = CreateStreamingActivity("Informative", text);
            _activitySubject.OnNext(activity);
        }

        /// <summary>
        /// Queues a chunk of partial message text to be sent to the client.
        /// </summary>
        /// <param name="text">Partial text of the message to send.</param>
        /// <param name="citations">Citations to include in the message.</param>
        /// <exception cref="System.InvalidOperationException">Throws if the stream has already ended.</exception>
        public void QueueTextChunk(string text)
        {
            if (string.IsNullOrEmpty(text) || _canceled)
            {
                return;
            }

            if (_ended)
            {
                throw Core.Errors.ExceptionHelper.GenerateException<InvalidOperationException>(ErrorHelper.StreamingResponseEnded, null);
            }

            if (!IsStreamingChannel)
            {
                // For non-streaming channels, just accumulate
                Message += text;
                Message = CitationUtils.FormatCitationsResponse(Message);
                return;
            }

            _streamStarted = true;
            _accumulatedMessage += text;
            Message = CitationUtils.FormatCitationsResponse(_accumulatedMessage);
            _textBatcher.OnNext(text);
        }


        /// <summary>
        /// Ends the stream by sending the final message to the client.
        /// </summary>
        /// <remarks>
        /// Since the messages are sent on an interval, this call will block until all have been sent
        /// before sending the final Message.
        /// </remarks>
        /// <returns>StreamingResponseResult with the result of the streaming response.</returns>
        public async Task<StreamingResponseResult> EndStreamAsync(CancellationToken cancellationToken = default)
        {
            if (!IsStreamingChannel)
            {
                if (_ended)
                {
                    return StreamingResponseResult.AlreadyEnded;
                }

                _ended = true;

                // Timer isn't running for non-streaming channels.  Just send the Message buffer as a message.
                if (UpdatesSent() > 0 || FinalMessage != null || !string.IsNullOrWhiteSpace(Message))
                {
                    await _context.SendActivityAsync(CreateFinalMessage(), cancellationToken).ConfigureAwait(false);
                }

                return StreamingResponseResult.Success;
            }
            else
            {
                if (_ended)
                {
                    return StreamingResponseResult.AlreadyEnded;
                }

                _ended = true;

                if (_canceled)
                {
                    return _userCanceled ? StreamingResponseResult.UserCancelled : StreamingResponseResult.Error;
                }

                if (!_streamStarted)
                {
                    return StreamingResponseResult.NotStarted;
                }

                // Complete the batcher and wait for all emissions
                _textBatcher?.OnCompleted();

                StreamingResponseResult result = StreamingResponseResult.Success;

                // Wait for stream to complete
                try
                {
                    // Complete the activity subject after a small delay to ensure batched items are sent
                    _ = Task.Run(async () =>
                    {
                        await Task.Delay(100, CancellationToken.None);
                        _activitySubject.OnCompleted();
                    }, CancellationToken.None);

                    var waitTask = _streamCompleteTcs.Task;
                    if (await Task.WhenAny(waitTask, Task.Delay(EndStreamTimeout, CancellationToken.None)) != waitTask)
                    {
                        result = StreamingResponseResult.Timeout;
                    }

                    if (_canceled)
                    {
                        return _userCanceled ? StreamingResponseResult.UserCancelled : StreamingResponseResult.Error;
                    }
                }
                catch
                {
                    _batcherSubscription?.Dispose();
                    _activitySubscription?.Dispose();
                }

                if (UpdatesSent() > 0 || FinalMessage != null)
                {
                    await SendActivityAsync(CreateFinalMessage(), cancellationToken).ConfigureAwait(false);
                }

                return result;
            }
        }

        private IActivity CreateFinalMessage()
        {
            var activity = FinalMessage ?? new Activity();

            activity.Type = ActivityTypes.Message;
            if (FinalMessage == null)
            {
                activity.Text = !string.IsNullOrEmpty(Message) ? Message : "No text was streamed";   // Teams won't allow Activity.Text changes or empty text
            }
            activity.Entities ??= [];

            // make sure the supplied Activity doesn't have a streamInfo already.
            var existingStreamInfos = activity.Entities.Where(e => string.Equals(EntityTypes.StreamInfo, e.Type, StringComparison.OrdinalIgnoreCase)).ToList();
            if (existingStreamInfos.Count != 0)
            {
                foreach (var existing in existingStreamInfos)
                {
                    activity.Entities.Remove(existing);
                }
            }

            if (IsStreamingChannel)
            {
                // Only append this if the channel supports streaming.
                activity.Entities.Add(new StreamInfo() { StreamType = StreamTypes.Final, StreamResult = (string.IsNullOrEmpty(Message) ? StreamResults.Error : StreamResults.Success) });
            }

            // Add in Generated by AI
            List<ClientCitation>? currCitations = CitationUtils.GetUsedCitations(Message, Citations);
            if ((bool)EnableGeneratedByAILabel || currCitations != null)
            {
                AIEntity entity = new()
                {
                    Citation = currCitations,
                    UsageInfo = SensitivityLabel
                };

                if (EnableGeneratedByAILabel == true)
                {
                    entity.AdditionalType.Add(AIEntity.AdditionalTypeAIGeneratedContent);
                }

                activity.Entities.Add(entity);
            }

            return activity;
        }

        /// <summary>
        /// Reset an already used stream.  If the stream is still running, this will wait for completion.
        /// </summary>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task ResetAsync(CancellationToken cancellationToken = default)
        {
            if (_streamStarted)
            {
                await EndStreamAsync(cancellationToken).ConfigureAwait(false);
            }

            _batcherSubscription?.Dispose();
            _activitySubscription?.Dispose();
            _textBatcher?.Dispose();

            _ended = false;
            FinalMessage = null;
            _nextSequence = 1;
            StreamId = null;
            _canceled = false;
            _userCanceled = false;
            _streamStarted = false;
            _accumulatedMessage = "";
            Message = "";
            _streamCompleteTcs = new TaskCompletionSource<bool>();

            if (IsStreamingChannel)
            {
                SetupStreamingPipeline();
            }
        }

        private void SetDefaults(TurnContext turnContext)
        {
            _isTeamsChannel = Channels.Msteams == turnContext.Activity.ChannelId?.Channel;
            int defaultInterval = 500;

            if (string.Equals(DeliveryModes.ExpectReplies, turnContext.Activity.DeliveryMode, StringComparison.OrdinalIgnoreCase))
            {
                // No point in streaming for ExpectReplies.  Treat as non-streaming channel.
                IsStreamingChannel = false;
            }
            else if (_isTeamsChannel)
            {
                if (turnContext.Activity.IsAgenticRequest())
                {
                    // Agentic requests do not support streaming responses at this time.
                    // TODO : Enable streaming for agentic requests when supported.
                    IsStreamingChannel = false;
                }
                else
                {
                    // Teams MUST use the Activity.Id returned from the first Informative message for
                    // subsequent intermediate messages.  Do not set StreamId here.

                    defaultInterval = 1000;
                    IsStreamingChannel = true;
                }
            }
            else if (Channels.Webchat == turnContext.Activity.ChannelId?.Channel || Channels.Directline == turnContext.Activity.ChannelId?.Channel)
            {
                defaultInterval = 500;
                IsStreamingChannel = true;

                // WebChat will use whatever StreamId is created.
                StreamId = Guid.NewGuid().ToString();
            }
            else if (string.Equals(DeliveryModes.Stream, turnContext.Activity.DeliveryMode, StringComparison.OrdinalIgnoreCase))
            {
                // Support streaming for DeliveryMode.Stream
                IsStreamingChannel = true;
                defaultInterval = 100;
                StreamId = Guid.NewGuid().ToString();
            }
            else
            {
                IsStreamingChannel = false;
            }

            Volatile.Write(ref _interval, defaultInterval);
        }

        public bool IsStreamStarted()
        {
            return _streamStarted;
        }

        private async Task SendActivityAsync(IActivity activity, CancellationToken cancellationToken)
        {
            if (activity != null)
            {
                if (!string.IsNullOrEmpty(StreamId))
                {
                    activity.Id = StreamId;
                    activity.GetStreamingEntity().StreamId = StreamId;
                }

                try
                {
                    var response = await _context.SendActivityAsync(activity, cancellationToken).ConfigureAwait(false);
                    if (string.IsNullOrEmpty(StreamId))
                    {
                        StreamId = response.Id;
                    }
                }
                catch (Exception ex)
                {
                    bool CanceledStream = true;
                    if (ex is ErrorResponseException errorResponse)
                    {
                        // User canceled?
                        if (TeamsStreamCancelled.Equals(errorResponse?.Body?.Error?.Code, StringComparison.OrdinalIgnoreCase))
                        {
                            _context?.Adapter?.Logger?.LogWarning("User canceled stream on the client side.");
                            System.Diagnostics.Trace.WriteLine("User canceled stream on the client side.");

                            _userCanceled = true;
                        }
                        // Stream not allowed?
#pragma warning disable CA1862 // Use the 'StringComparison' method overloads to perform case-insensitive string comparisons - this is to support older .NET versions
                        else if (BadArgument.Equals(errorResponse?.Body?.Error?.Code, StringComparison.OrdinalIgnoreCase) &&
                            errorResponse?.Body?.Error?.Message.ToLower().Contains(TeamsStreamNotAllowed) == true)
                        {
                            _context?.Adapter?.Logger?.LogWarning("Interaction Context does not support StreamingResponse, StreamingResponse has been disabled for this turn");
                            System.Diagnostics.Trace.WriteLine("Interaction Context does not support StreamingResponse, StreamingResponse has been disabled for this turn");

                            IsStreamingChannel = false; // Disabled Streaming for this channel / interaction as teams will not accept it at this time. 
                            CanceledStream = false;
                        }
#pragma warning restore CA1862 // Use the 'StringComparison' method overloads to perform case-insensitive string comparisons
                        else
                        {
                            var errorMessage = errorResponse?.Body?.Error?.Message ?? "None";

                            _context?.Adapter?.Logger?.LogWarning(
                                "Exception during StreamingResponse: {ExceptionMessage} - {ErrorMessage}",
                                ex.Message,
                                errorMessage);

                            System.Diagnostics.Trace.WriteLine($"Exception during StreamingResponse: {ex.Message} - {errorMessage}");
                        }

                        if (CanceledStream)
                        {
                            _context?.Adapter?.Logger?.LogWarning("User canceled stream on the client side.");
                            System.Diagnostics.Trace.WriteLine("User canceled stream on the client side.");
                        }
                    }

                    _canceled = CanceledStream;
                    _batcherSubscription?.Dispose();
                    _activitySubscription?.Dispose();
                    _streamCompleteTcs.TrySetResult(true);
                }
            }
        }
    }
}