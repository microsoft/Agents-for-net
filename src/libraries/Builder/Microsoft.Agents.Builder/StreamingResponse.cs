// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using Microsoft.Agents.Builder.Errors;
using Microsoft.Agents.Core;
using Microsoft.Agents.Core.Errors;
using Microsoft.Agents.Core.Models;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reactive;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.Agents.Builder
{
    /// <summary>
    /// Represents the state of the streaming response.
    /// </summary>
    internal enum StreamState
    {
        Initial,
        Streaming,
        Ended,
        Canceled,
        UserCanceled,
        Error
    }

    /// <summary>
    /// This class enables sending chunked text in a series of "intermediate" messages, on an interval.  This
    /// gives the UX of a streamed message. When complete, a final message (ActivityType.Message) is sent with
    /// the full message and optional Attachments.
    ///
    /// The expected sequence of calls is:
    ///
    /// `QueueInformativeUpdateAsync()`, `QueueTextChunk()`, `QueueTextChunk()`, ..., `EndStreamAsync()`.
    ///
    ///  Once `EndStreamAsync()` is called, the stream is considered ended and no further updates can be sent.
    /// </summary>
    /// <remarks>
    /// Only Teams and WebChat support streaming messages.  However, channels that do not support
    /// streaming messages will only receive the final message when <see cref="EndStreamAsync"/> is called.
    /// </remarks>
    /// <remarks>
    /// This class support throttling via the <see cref="Interval"/> property.  Teams and Azure Channels require
    /// some throttling since services like OpenAI produce streams that exceed allowed Channel message limits.
    /// Teams defaults to 1000ms per intermediate message, and WebChat 500ms.  Reducing the Interval could result
    /// in message delivery failures.
    /// </remarks>
    internal class StreamingResponse : IStreamingResponse, IDisposable
    {
        public static readonly int DefaultEndStreamTimeout = (int)TimeSpan.FromMinutes(2).TotalMilliseconds;

        private const string TeamsStreamCancelled = "ContentStreamNotAllowed";
        private const string BadArgument = "BadArgument";
        private const string TeamsStreamNotAllowed = "streaming api is not enabled";

        private readonly TurnContext _context;
        private readonly BehaviorSubject<StreamState> _state = new(StreamState.Initial);
        private readonly Subject<Func<IActivity>> _activityQueue = new();
        private readonly CompositeDisposable _subscriptions = new();
        private readonly TaskCompletionSource<object> _streamComplete = new();

        private int _nextSequence = 1;
        private string _accumulatedMessage = "";
        private DynamicIntervalTextChunkBatcher _textBatcher;
        private IDisposable _batcherSubscription;
        private bool _isTeamsChannel;
        private bool _disposed;
        private IDisposable _streamSubscription;

        /// <summary>
        /// Set IActivity that will be (optionally) used for the final streaming message.
        /// </summary>
        public IActivity FinalMessage { get; set; }

        /// <summary>
        /// Gets the stream ID of the current response.
        /// Assigned after the initial update is sent.
        /// </summary>
        private string StreamId { get; set; }

        /// <summary>
        /// The buffered message.
        /// </summary>
        public string Message { get; private set; } = "";

        /// <summary>
        /// Sets the "Generated by AI" label in Teams.
        /// Defaults to false.
        /// </summary>
        public bool? EnableGeneratedByAILabel { get; set; } = false;

        /// <summary>
        /// The citations for the response.
        /// </summary>
        public List<ClientCitation>? Citations { get; set; } = [];

        /// <summary>
        /// The sensitivity label for the response.
        /// </summary>
        public SensitivityUsageInfo? SensitivityLabel { get; set; }

        /// <summary>
        /// The interval in milliseconds at which intermediate messages are sent.
        /// </summary>
        /// <remarks>
        /// Teams default: 1000
        /// WebChat default: 500
        /// </remarks>
        public int Interval { get; set; }

        public int EndStreamTimeout { get; set; } = DefaultEndStreamTimeout;

        /// <summary>
        /// Indicate if the current channel supports intermediate messages.
        /// </summary>
        /// <remarks>
        /// Channels that don't support intermediate messages will buffer
        /// text, and send a normal final message when EndStreamAsync is called.
        /// </remarks>
        public bool IsStreamingChannel { get; private set; }

        /// <summary>
        /// Gets the number of updates sent for the stream.
        /// </summary>
        /// <returns>Number of updates sent so far.</returns>
        public int UpdatesSent() => _nextSequence - 1;

        /// <summary>
        /// Creates a new instance of the <see cref="StreamingResponse"/> class.
        /// </summary>
        /// <param name="turnContext">Context for the current turn of conversation with the user.</param>
        public StreamingResponse(TurnContext turnContext)
        {
            AssertionHelpers.ThrowIfNull(turnContext, nameof(turnContext));

            _context = turnContext;
            SetDefaults(turnContext);
        }

        /// <summary>
        /// Adds a citation to the collection at the specified position.
        /// </summary>
        /// <remarks>The citation's appearance is automatically generated based on its title, content, and URL.</remarks>
        /// <param name="citation">The citation to add. Must not be <see langword="null"/>.</param>
        /// <param name="citationPosition">The position of the citation in the collection. Must be a non-negative integer.</param>
        public void AddCitation(Citation citation, int citationPosition)
        {
            Citations ??= [];
            Citations.Add(new ClientCitation()
            {
                Position = citationPosition,
                Appearance = new ClientCitationAppearance()
                {
                    Name = citation.Title ?? $"Document #{citationPosition}",
                    Abstract = CitationUtils.Snippet(citation.Content, 480),
                    Url = citation.Url
                }
            });
        }

        /// <summary>
        ///  Sets the citations for the full message.
        /// </summary>
        /// <remarks>The citation's appearance is automatically generated based on its title, content, and URL. Citations are numbed in the order they appear on the list.</remarks>
        /// <param name="citations">Citations to be included in the message.</param>
        public void AddCitations(IList<Citation> citations)
        {
            if (citations.Count > 0)
            {
                Citations ??= [];

                int currPos = Citations.Count;

                foreach (Citation citation in citations)
                {
                    Citations.Add(new ClientCitation()
                    {
                        Position = currPos + 1,
                        Appearance = new ClientCitationAppearance()
                        {
                            Name = citation.Title ?? $"Document #{currPos + 1}",
                            Abstract = CitationUtils.Snippet(citation.Content, 480),
                            Url = citation.Url
                        }
                    });
                    currPos++;
                }
            }
        }

        /// <summary>
        /// Adds a ClientCitation to the Citations list.
        /// </summary>
        /// <param name="citation">ClientCitation to add to the stream</param>
        public void AddCitation(ClientCitation citation)
        {
            Citations ??= [];
            Citations.Add(citation);
        }

        /// <summary>
        /// Adds multiple ClientCitations to the Citations list.
        /// </summary>
        /// <param name="citations">The ClientCitations to add.</param>
        public void AddCitations(IList<ClientCitation> citations)
        {
            if (citations.Count > 0)
            {
                Citations ??= [];
                Citations.AddRange(citations);
            }
        }

        /// <summary>
        /// Queues an informative update to be sent to the client.
        /// </summary>
        /// <param name="text">Text of the update to send.</param>
        /// <param name="cancellationToken"></param>
        /// <exception cref="System.InvalidOperationException">Throws if the stream has already ended.</exception>
        public async Task QueueInformativeUpdateAsync(string text, CancellationToken cancellationToken = default)
        {
            if (!IsStreamingChannel)
            {
                return;
            }

            var currentState = _state.Value;
            if (currentState == StreamState.Ended || currentState == StreamState.Canceled || currentState == StreamState.UserCanceled || currentState == StreamState.Error)
            {
                throw Core.Errors.ExceptionHelper.GenerateException<InvalidOperationException>(ErrorHelper.StreamingResponseEnded, null);
            }

            Func<IActivity> queueFunc = () =>
            {
                return new Activity
                {
                    Type = ActivityTypes.Typing,
                    Text = text,
                    Entities = [new StreamInfo()
                        {
                            StreamType = StreamTypes.Informative,
                            StreamSequence = Interlocked.Increment(ref _nextSequence) - 1,
                        }]
                };
            };

            if (IsStreamStarted())
            {
                _activityQueue.OnNext(queueFunc);
                return;
            }

            // Stream hasn't started - send directly and start
            await SendActivityAsync(queueFunc(), cancellationToken).ConfigureAwait(false);
            StartStream();
        }

        /// <summary>
        /// Queues a chunk of partial message text to be sent to the client.
        /// </summary>
        /// <param name="text">Partial text of the message to send.</param>
        /// <param name="citations">Citations to include in the message.</param>
        /// <exception cref="System.InvalidOperationException">Throws if the stream has already ended.</exception>
        public void QueueTextChunk(string text)
        {
            var currentState = _state.Value;
            if (string.IsNullOrEmpty(text) || currentState == StreamState.Canceled || currentState == StreamState.UserCanceled || currentState == StreamState.Error)
            {
                return;
            }

            if (currentState == StreamState.Ended)
            {
                throw Core.Errors.ExceptionHelper.GenerateException<InvalidOperationException>(ErrorHelper.StreamingResponseEnded, null);
            }

            // Buffer all chunks
            _accumulatedMessage += text;

            // If there are citations, modify the content so that the sources are numbers instead of [doc1], [doc2], etc.
            Message = CitationUtils.FormatCitationsResponse(_accumulatedMessage);

            // Update state and start stream if needed
            if (_state.Value == StreamState.Initial)
            {
                _state.OnNext(StreamState.Streaming);
            }

            // Start stream if needed. The 250 allows for a quicker stream (better UX) if Informative hadn't been sent
            // and we're just now starting the stream.
            StartStream(250);

            // Feed the text to the batcher (thread-safe via Rx)
            _textBatcher?.OnNext(text);
        }

        /// <summary>
        /// Ends the stream by sending the final message to the client.
        /// </summary>
        /// <remarks>
        /// Since the messages are sent on an interval, this call will block until all have been sent
        /// before sending the final Message.
        /// </remarks>
        /// <returns>StreamingResponseResult with the result of the streaming response.</returns>
        public async Task<StreamingResponseResult> EndStreamAsync(CancellationToken cancellationToken = default)
        {
            var currentState = _state.Value;

            if (!IsStreamingChannel)
            {
                if (currentState == StreamState.Ended)
                {
                    return StreamingResponseResult.AlreadyEnded;
                }

                _state.OnNext(StreamState.Ended);

                // Timer isn't running for non-streaming channels. Just send the Message buffer as a message.
                if (UpdatesSent() > 0 || FinalMessage != null || !string.IsNullOrWhiteSpace(Message))
                {
                    await _context.SendActivityAsync(CreateFinalMessage(), cancellationToken).ConfigureAwait(false);
                }

                return StreamingResponseResult.Success;
            }
            else
            {
                if (currentState == StreamState.Ended)
                {
                    return StreamingResponseResult.AlreadyEnded;
                }

                if (currentState == StreamState.Canceled || currentState == StreamState.Error)
                {
                    _state.OnNext(StreamState.Ended);
                    return StreamingResponseResult.Error;
                }

                if (currentState == StreamState.UserCanceled)
                {
                    _state.OnNext(StreamState.Ended);
                    return StreamingResponseResult.UserCancelled;
                }

                if (!IsStreamStarted())
                {
                    _state.OnNext(StreamState.Ended);
                    return StreamingResponseResult.NotStarted;
                }

                _state.OnNext(StreamState.Ended);
                _activityQueue.OnCompleted();

                StreamingResponseResult result = StreamingResponseResult.Success;

                // Wait for queue items to be sent per Interval
                try
                {
                    using (var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken))
                    {
                        cts.CancelAfter(EndStreamTimeout);

                        var timeoutTask = Task.Delay(Timeout.InfiniteTimeSpan, cts.Token);
                        var completedTask = await Task.WhenAny(_streamComplete.Task, timeoutTask).ConfigureAwait(false);

                        if (completedTask == timeoutTask && cts.IsCancellationRequested)
                        {
                            result = StreamingResponseResult.Timeout;
                        }
                    }

                    var finalState = _state.Value;
                    if (finalState == StreamState.UserCanceled)
                    {
                        return StreamingResponseResult.UserCancelled;
                    }
                    if (finalState == StreamState.Canceled || finalState == StreamState.Error)
                    {
                        return StreamingResponseResult.Error;
                    }
                }
                catch (AbandonedMutexException)
                {
                    StopStream();
                }

                if (UpdatesSent() > 0 || FinalMessage != null)
                {
                    await SendActivityAsync(CreateFinalMessage(), cancellationToken).ConfigureAwait(false);
                }

                return result;
            }
        }

        private IActivity CreateFinalMessage()
        {
            var activity = FinalMessage ?? new Activity();

            activity.Type = ActivityTypes.Message;
            if (FinalMessage == null)
            {
                activity.Text = !string.IsNullOrEmpty(Message) ? Message : "No text was streamed";   // Teams won't allow Activity.Text changes or empty text
            }
            activity.Entities ??= [];

            // make sure the supplied Activity doesn't have a streamInfo already.
            var existingStreamInfos = activity.Entities.Where(e => string.Equals(EntityTypes.StreamInfo, e.Type, StringComparison.OrdinalIgnoreCase)).ToList();
            if (existingStreamInfos.Count != 0)
            {
                foreach (var existing in existingStreamInfos)
                {
                    activity.Entities.Remove(existing);
                }
            }

            if (IsStreamingChannel)
            {
                // Only append this if the channel supports streaming.
                activity.Entities.Add(new StreamInfo() { StreamType = StreamTypes.Final, StreamResult = (string.IsNullOrEmpty(Message) ? StreamResults.Error : StreamResults.Success) });
            }

            // Add in Generated by AI
            List<ClientCitation>? currCitations = CitationUtils.GetUsedCitations(Message, Citations);
            if ((bool)EnableGeneratedByAILabel || currCitations != null)
            {
                AIEntity entity = new()
                {
                    Citation = currCitations,
                    UsageInfo = SensitivityLabel
                };

                if (EnableGeneratedByAILabel == true)
                {
                    entity.AdditionalType.Add(AIEntity.AdditionalTypeAIGeneratedContent);
                }

                activity.Entities.Add(entity);
            }

            return activity;
        }

        /// <summary>
        /// Reset an already used stream.  If the stream is still running, this will wait for completion.
        /// </summary>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async Task ResetAsync(CancellationToken cancellationToken = default)
        {
            if (IsStreamStarted())
            {
                await EndStreamAsync(cancellationToken).ConfigureAwait(false);
            }

            StopStream();

            // Dispose of the batcher
            _batcherSubscription?.Dispose();
            _batcherSubscription = null;
            _textBatcher?.Dispose();
            _textBatcher = null;

            _state.OnNext(StreamState.Initial);
            FinalMessage = null;
            _nextSequence = 1;
            StreamId = null;
            Message = "";
            _accumulatedMessage = "";
        }

        private void SetDefaults(TurnContext turnContext)
        {
            _isTeamsChannel = Channels.Msteams == turnContext.Activity.ChannelId?.Channel;

            if (string.Equals(DeliveryModes.ExpectReplies, turnContext.Activity.DeliveryMode, StringComparison.OrdinalIgnoreCase))
            {
                // No point in streaming for ExpectReplies.  Treat as non-streaming channel.
                IsStreamingChannel = false;
            }
            else if (_isTeamsChannel)
            {
                if (turnContext.Activity.IsAgenticRequest())
                {
                    // Agentic requests do not support streaming responses at this time.
                    IsStreamingChannel = false;
                }
                else
                {
                    // Teams MUST use the Activity.Id returned from the first Informative message for
                    // subsequent intermediate messages.  Do not set StreamId here.
                    Interval = 1000;
                    IsStreamingChannel = true;
                }
            }
            else if (Channels.Webchat == turnContext.Activity.ChannelId?.Channel || Channels.Directline == turnContext.Activity.ChannelId?.Channel)
            {
                Interval = 500;
                IsStreamingChannel = true;

                // WebChat will use whatever StreamId is created.
                StreamId = Guid.NewGuid().ToString();
            }
            else if (string.Equals(DeliveryModes.Stream, turnContext.Activity.DeliveryMode, StringComparison.OrdinalIgnoreCase))
            {
                // Support streaming for DeliveryMode.Stream
                IsStreamingChannel = true;
                Interval = 100;
                StreamId = Guid.NewGuid().ToString();
            }
            else
            {
                IsStreamingChannel = false;
            }
        }

        public bool IsStreamStarted()
        {
            return _streamSubscription != null;
        }

        private void StartStream(int initialDelay = 0)
        {
            if (_streamSubscription == null && IsStreamingChannel)
            {
                SetupStreamPipeline(initialDelay == 0 ? Interval : initialDelay);
            }
        }

        private void SetupStreamPipeline(int initialInterval)
        {
            // Set up the text batcher for lock-free text chunk batching
            // Note: initialInterval is not used because the batcher emits immediately on first text
            // (via CombineLatest with StartWith), providing even faster UX than the original timer approach
            _textBatcher = new DynamicIntervalTextChunkBatcher(Interval);

            // Subscribe to batched text emissions and queue streaming activities
            _batcherSubscription = _textBatcher
                .TakeUntil(_state.Where(s => s == StreamState.Ended || s == StreamState.Canceled || s == StreamState.UserCanceled || s == StreamState.Error))
                .Subscribe(text =>
                {
                    _activityQueue.OnNext(CreateChunkActivityFactory());
                });

            // Create observable that produces activities on interval
            var activityStream = Observable.Create<Func<IActivity>>(observer =>
            {
                var subscription = _activityQueue.Subscribe(
                    onNext: factory => observer.OnNext(factory),
                    onError: ex => observer.OnError(ex),
                    onCompleted: () => observer.OnCompleted()
                );

                return subscription;
            });

            // Process activities with throttling - use maxConcurrent: 1 to ensure sequential sending
            _streamSubscription = activityStream
                .TakeUntil(_state.Where(s => s == StreamState.Canceled || s == StreamState.UserCanceled || s == StreamState.Error))
                .Select(factory => Observable.FromAsync(async ct =>
                {
                    var activity = factory();
                    await SendActivityAsync(activity, ct).ConfigureAwait(false);
                    return Unit.Default;
                }))
                .Concat()
                .Subscribe(
                    onNext: _ => { },
                    onError: ex =>
                    {
                        _state.OnNext(StreamState.Error);
                        _streamComplete.TrySetResult(null);
                    },
                    onCompleted: () =>
                    {
                        _streamComplete.TrySetResult(null);
                    }
                );

            _subscriptions.Add(_streamSubscription);
        }

        private Func<IActivity> CreateChunkActivityFactory()
        {
            return () =>
            {
                var currentMessage = Message;

                var activity = new Activity
                {
                    Type = ActivityTypes.Typing,
                    Text = currentMessage,
                    Entities = []
                };

                var sequence = Interlocked.Increment(ref _nextSequence) - 1;

                activity.Entities.Add(new StreamInfo()
                {
                    StreamType = StreamTypes.Streaming,
                    StreamSequence = sequence,
                });

                if (Citations != null && Citations.Count > 0)
                {
                    // If there are citations, filter out the citations unused in content.
                    List<ClientCitation>? currCitations = CitationUtils.GetUsedCitations(currentMessage, Citations);
                    AIEntity entity = new();
                    if (currCitations != null && currCitations.Count > 0)
                    {
                        entity.Citation = currCitations;
                    }

                    activity.Entities.Add(entity);
                }

                return activity;
            };
        }

        private void StopStream()
        {
            _streamSubscription?.Dispose();
            _streamSubscription = null;
        }

        private async Task SendActivityAsync(IActivity activity, CancellationToken cancellationToken)
        {
            if (activity != null)
            {
                if (!string.IsNullOrEmpty(StreamId))
                {
                    activity.Id = StreamId;
                    activity.GetStreamingEntity().StreamId = StreamId;
                }

                try
                {
                    var response = await _context.SendActivityAsync(activity, cancellationToken).ConfigureAwait(false);
                    if (string.IsNullOrEmpty(StreamId))
                    {
                        StreamId = response.Id;
                    }
                }
                catch (Exception ex)
                {
                    // We are not rethrowing from here since this could be called from a background thread.
                    HandleSendError(ex);
                }
            }
        }

        private void HandleSendError(Exception ex)
        {
            bool canceledStream = true;

            if (ex is ErrorResponseException errorResponse)
            {
                // User canceled?
                if (TeamsStreamCancelled.Equals(errorResponse?.Body?.Error?.Code, StringComparison.OrdinalIgnoreCase))
                {
                    _context?.Adapter?.Logger?.LogWarning("User canceled stream on the client side.");
                    System.Diagnostics.Trace.WriteLine("User canceled stream on the client side.");

                    _state.OnNext(StreamState.UserCanceled);
                    _streamComplete.TrySetResult(null);
                    return;
                }
                // Stream not allowed?
#pragma warning disable CA1862 // Use the 'StringComparison' method overloads to perform case-insensitive string comparisons - this is to support older .NET versions
                else if (BadArgument.Equals(errorResponse?.Body?.Error?.Code, StringComparison.OrdinalIgnoreCase) &&
                    errorResponse?.Body?.Error?.Message.ToLower().Contains(TeamsStreamNotAllowed) == true)
                {
                    _context?.Adapter?.Logger?.LogWarning("Interaction Context does not support StreamingResponse, StreamingResponse has been disabled for this turn");
                    System.Diagnostics.Trace.WriteLine("Interaction Context does not support StreamingResponse, StreamingResponse has been disabled for this turn");

                    IsStreamingChannel = false;
                    canceledStream = false;
                }
#pragma warning restore CA1862
                else
                {
                    var errorMessage = errorResponse?.Body?.Error?.Message ?? "None";

                    _context?.Adapter?.Logger?.LogWarning(
                        "Exception during StreamingResponse: {ExceptionMessage} - {ErrorMessage}",
                        ex.Message,
                        errorMessage);

                    System.Diagnostics.Trace.WriteLine($"Exception during StreamingResponse: {ex.Message} - {errorMessage}");
                }
            }

            if (canceledStream)
            {
                _state.OnNext(StreamState.Canceled);
                StopStream();
                _streamComplete.TrySetResult(null);
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    StopStream();
                    _batcherSubscription?.Dispose();
                    _textBatcher?.Dispose();
                    _subscriptions.Dispose();
                    _activityQueue.Dispose();
                    _state.Dispose();
                }
                _disposed = true;
            }
        }
    }
}
